### dfs_bfs
- bfs/p8693
    - **f 既可以表示小明的状态，也可以表示他站的位置**

- bfs/p2895
    - **g 的下标为点的坐标，值可以灵活变化，题中的值为陨石的降落时间，下标是陨石的坐标**

- dfs/p2036
    - **关于回溯**

- dfs/p1605
    - **深搜的一个小技巧**

- dfs/p1101
    - **dfs的返回值**

- dfs/p2404
    - **dfs的参数**

- dfs/p1036
    - **需不需要去重**

- dfs/p5194
    - **利用前缀和数组进行剪枝**

- bfs/p3956
    - **可以重复走**

### 最短路算法

- path/p8802
    - **注意是有向图还是无向图**
    - **当点有权值时，可以将其附加在边上**
- path/p1144
    - **SPFA对于for循环的进一步理解**
    - **权值为1时的情况**
- path/p4568
    - **分层图模板题**
    - **对于空间的计算**
- path/p1073
    - **分层图适用于状态的转换**
    - **该题中，买入水晶球与卖出水晶球都是一种状态，决定执行后，便从当前点到下层图的对应点**
    - **要注意分层图的建立方式，是 点i下一层到达的点 还是 到下一层的点i**
- path/p1522
    - **使用并查集区分联通块**
    - **Floyd算法**
- path/p6464
    - **Floyd算法是以k为中转站从i到j的最短路**
    - **如该题，不需要以所有点为中转站，只需要对经过x和y的点重新计算最短路即可，其它点在一开始做过**
- path/p2419
    - **Floyd算法的松弛操作可以不固定，如题**
- path/p1993
    - **负环的差分约束系统**
    - **将约束条件转换为类似松弛操作的形式，建边，然后判断是否有负环，若有环，则无解**
    - **改写为 xi <= xj + c, 那么 j->i 建立权值为c的边**
- path/p5960
    - **差分约束模板题**
    - **一组可行解为dist[1 ~ n]**
    - **松弛操作的目的是为了使 dist[j] <= dist[t] + w[i]**

- acWing/1170(排队布局, 判断二者之间是否有约束关系)
    - **在差分约束系统中,二者有无关系在经过计算后, 是否连通**

- path/p1993、p3385、p5960
    - **新的判断负环的方式**
- path/p1119
    - **Floyd算法的本质：一层层扩大子图直至包含全部点，即最外层循环**
- path/p1613
    - **倍增化的思想**
- path/B3611
    - **传递闭包模板题**
    - **使用bitset优化**
- path/p1730
    - **改变Floyd对于g状态的划分**
    - **ios::sync_with_stdio()与cin.tie()的好处与副作用**
- path/p3275
    - **差分约束系统求最小值时，要跑最长路，同时要反序建边, y总视频提高课差分约束30:30左右**
    - **本体数据加强过，单纯SPFA应该过不了, 使用经验上的trick**

- acWing/1126
    - **乘法的最远路，同加法最短路**
    - **对于加法来说，Dijkstra与SPFA区别于是都有负权，因为Dijkstra是以贪心的思想，必须保证确定为最短路的点不会再后续遍历中变得更小，在乘法中这个区别是大于和小于1，乘小于1的数会使值变小（在乘法中，值不能小于0）**

- acWing/920
    - **对于该题，每条路线都相当于是一个连通块，将各个连通块内的点按照规则(本题即为巴士的顺序)连接起来，这样可以确保一个连通块内可以无代价的移动**

- acWing/903
    - **建图很重要：分析题意；模拟样例找到建图方式；**
    - **起点与终点：本题的起点是一个虚拟源点，终点是dist[1]**
    - **枚举等级的范围**

- acWing/1135
    - **dfs与最短路的结合**

- acWing/342
    - **拓扑排序与Dij的结合,将道路所连的点当作一个连通块(缩点),对每个连通块跑Dij,块与块是DAG,跑topsort**
    - **用dfs构造连通块**
    - **topsort的本质:**

- acWing/1137
    - **多起点的单源最短路,利用虚拟源点向所有起点连一条边权为0的边,并设起点从虚拟源点开始**

- acWing/383
    - **最短路与次短路的条数**

- acWing/345(牛站)
    - **floyd算法的变形,使用了备份数组防止串联,类似于Bellman-Ford**
    - **点的编号为1000, 旦实际使用做多为200, 利用离散化重新初始化点的编号**
    - **通过的边的数量可以很多,如果一个一个的枚举很慢,利用倍增的思想**

- 牛客周赛33-E
    - **最短路新的建图方式**
    - **该题点的编号是二维，这样遍历邻点时也很方便**

- 最小生成树的性质
    - **MST一定包含图中权值最小的边**
    - **所有连通块之间的权值最小的边也一定在MST中**

- acWing/1146
    - **虚拟源点在最小生成树中的一种应用**

- acWing/1145
    - **kruskal算法第i次循环时若满足if条件，那么连通块的数量少一个（一开始有n个）**

- acWing/346
    - **已知最小生成树，求其完全图**
    - **_size数组维护连通块内点的个数**

- cf-928/E
    - **预处理 + 前缀和**

- abc-342/C
    - **使用to数组记录每个字母最终的样子，来代替一个一个遍历替换**

- abc-342/D
    - **1.质因数分解定理：任何一个大于1的整数n都可以分解成若干个质因数的乘积**
    - **2.完全平方数：a * a = d**
    - **3.由 1 和 2 可知平方数的每一个质因子都是偶数次**

- abc-344/E (list/ex)
    - **一道链表的题，链表的插入删除操作其实很快，主要花费是查找**
    - **故利用mp<int, list<int>::iterator>将元素的迭代器存起来，查找操作就很快**
    - **※注意：本题的链表中的元素是不重复的**

- abc-344/D (dp/)
    - **根本看不出来是dp（可能是题做少了？）**
    - **感觉dp的状态一般都是前i组、前i行的第j个啥的**
    - **本题类似与分组dp，每组选一个或者不选**

- 牛客周赛-36/C
    - **isupper函数，判断一个字符是否是大写** 

- 天梯赛题目集/L2-001
    - **最短路计数由洛谷p1144**
    - **本题在满足最短路的前提下，要求计算出最大点权和，需要在更新最短路时同时更新点权之和，当之后碰到最短路相同的情况时，要更新最大点权之和**
    - **学会了如何记录路劲（不过本题输出格式要求严格，使用了vector存取路径）**
    - **最短路计数以及满足要求下的最大点权之和分别使用了cnt数组和num数组，cnt[i]和num[i]分别代表了从起点到i点（或者说是以i点为结尾，这么看确实好像dp）时的最短路径条数和最大点权之和**

- 单调栈
    - **参考文献：https://www.cnblogs.com/molinchn/p/14772025.html**

- 二叉树的遍历
    - **L2-035: 已知二叉树的后序遍历，求层序遍历**
    - **L2-011: 已知二叉树的中序和前\层\后序遍历，还原树**

- 最小堆
    - **建堆的方式**
    - **对输入的一种处理方法**

- L2-014：列车调度
    - **用一维代替了二维，一种优化方式**

- L2-020：功夫传人
    - **dfs的剪枝优化**

- L2-022：重排链表
    - **模拟链表：将链表按某种顺序打印**
    - **将该链表变为双向链表**

- bfs:abc-348-d
    - **每个点可以重复走时的st数组**

- dataStructure/heap/牛客小白月赛90-E
    - **考察了对于优先队列（堆）的使用**
    - **使用大根堆维护了k个最小的b，当size==k+1时，队头剔除**

- p2024:种类并查集
    - 。。。不知道说啥

- 区间DP
    - **特征：每一次操作都是的对象都是一个范围**
    - **核心思想：由一个个小区间合并为大区间，一般从长度最小的开始往大枚举**
    - **一般需要考虑跟区间左右端点i、j相邻的位置（即i - 1与j + 1）的关系**
    - **很类似与floyd算法的思想，不断找中转点k来更新dp[i][j]**

- ABC347-D/位运算，模拟

- ABC334-C/前缀和
    - **通过前缀和与后缀和，来达到枚举所有元素的一种方法（话说以前好像见过）**

- p1095：线性动态规划
- p3842：线性动态规划
- AcWing算法提高课1014：登山
    - **最长上升子序列的状态数组，以i开始可以转换为倒着枚举的以i结束**
- AcWing算法提高可1016：最大上升子序列和
    - **深入理解了上升子序列的模型**

- p2622：关灯问题Ⅱ
    - **套着状态压缩的bfs**

- AcWing算法提高课：1068 环形石子合并
    - **index:** $\color{red} 划环为链$
    - **summary:** 本质与石子合并相同，但将链变为环
    - **solve:**
      - 1. 将环沿某一条边断开，剩下的部分变为链，需要多加一层循环来枚举端点
      - 2. 将数组扩大一倍，将数组复制后拼接至原数组后边，右端点的值小于`n << 1`
        - 可以从第一种方法的角度来看 

- AcWing算法提高课：479 加分二叉树
    - **index:** $\color{red} 树的向下投影、树的中序遍历与区间dp$
    - **summary:** 每棵树都由更小的树合并而来，就像区间dp中的大区间由更小的区间合并而来
    - **solve:** 如题
  
- Atcoder357：C题 Sierpinski carpet
    - **index:** $\color{red} 利用dfs递归打印$
    - **summary:** 先将字符存下来，处理完后打印

- basic/ruler/Atcoder355: D题 Intersecting Intervals
    - **index:** $\color{red} 利用双指针计算相交区间$
    - **summary:** 正难则反, 计算不可能相交数

- datStructure/tree/百炼4081树的转换
    - **index:** $\color{red} 树转换为二叉树后的深度变化$
    - **summary:** 转换后每个节点的深度 = 父节点的深度 + 父节点的第几个孩子

- other/Atcoder354: C题 AtCoder Magics
    - **index:** $\color{red} 本质是寻找逆序对$
    - **summary:** 需要排序其中一个数字, 循环计算另一个数字的基准
  
- dp/treedp/Atcoder333: D题 Erase Leaves
    - **index:** $\color{red} 树形dp, 求数的最大边权(本题为1)$
    - **summary:** 在只能删除叶子节点的情况下删除根节点的最小代价的转换